# -*- coding: utf-8 -*-
"""Primeiro Turno de Eleições Presidenciais no Brasil 2018 - Lucas Gomes Dantas.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/177O-lMxW7SqzMS0H7K_9SCc29ZSvDBzW

# 1 - Contextualização

Ocorreu no dia** 7 de outubro de 2018** o primeiro turno das eleições presidenciais no Brasil. Como era de se esperar de um evento dessa magnitude, foram feitas várias pesquisas para levantar estimativas sobre o resultado e saber quais candidatos conseguiriam os melhores resultados.

Após a apuração dos votos, o **Tribunal Superior Eleitoral (TSE)** liberou bases de dados com o resultado. Foi adquirido, para essa tarefa, uma base com informações referentes aos votos de **todos os municípios** do Brasil para Presidente e outra base, que será utilizada em trabalho futuro, com informações sobre os municípios do Rio Grande do Norte.

O objetivo é analisar os dados contidos nessas bases e gerar gráficos informativos que possam ajudar a tirar conclusões e a inferir informações importantes sobre o cenário político no país. Utilizarei a linguagem de programação **Python** com o auxílio de bibliotecas e módulos próprios para análise e visualização de dados.

A pesquisa está sendo conduzida por mim,** Lucas Gomes Dantas**, aluno da disciplina de **Probabilidade** lecionada pelo professor doutor **Ivanovitch Medeiros Dantas da Silva** na **Universidade Federal do Rio Grande do Norte**.

# 2 - Configurações iniciais

Antes mesmo de começar a importar bibliotecas e tratar os dados, precisamos... dos dados! Execute a célula abaixo para importar a bases de dados que será utilizadas nessa análise:
"""

!pip3 install seaborn==0.9.0

# Código fornecido pelo Professor Doutor Ivanovitch Medeiros Dantas da Silva
# Suba o arquivo "votacao_candidato_munzona_2018_BR"
from google.colab import files
uploaded = files.upload()
for fn in uploaded.keys():
  print('User uploaded file "{name}" with length {length} bytes'.format(
      name=fn, length=len(uploaded[fn])))

"""Com isso feito, podemos começar a importar as bibliotecas úteis para a jornada: **[Pandas](https://pandas.pydata.org/://)**, **[NumPy](http://www.numpy.org/)**, **[Matplotlib](https://matplotlib.org/)** e **[Seaborn](https://seaborn.pydata.org/)**. Referências e documentação para as respectivas ferramentas podem ser encontradas nos links anexados ao nome de cada uma."""

# Importando as bibliotecas necessárias
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

"""Após a importação, é necessário carregar o arquivo como um dataframe do **Pandas**."""

# Lendo o dataset para o Pandas e exibindo as 5 primeiras linhas
candidatos_dataset = pd.read_csv("votacao_candidato_munzona_2018_BR.csv", sep=";", encoding='latin-1')
candidatos_dataset.head()

"""São muitas colunas! Porém não se preocupe, para essa análise não utilizaremos todas. Caso se pergunte a informação que cada uma delas contém, o TSE liberou um manual onde essa informação está contida:

* **DT_GERACAO** - Data de extração dos dados para geração dos arquivos;
* **HH_GERACAO** - Hora de extração dos dados para geração dos arquivos (horário de Brasília);
* **ANO_ELEICAO** - Ano da eleição;
* **CD_TIPO_ELEICAO** - Código do tipo de eleição;
* **NM_TIPO_ELEICAO** - Nome do tipo de eleição;
* **NR_TURNO** - Número do turno da eleição;
* **CD_ELEICAO** - Código da eleição;
* **DS_ELEICAO** - Descrição da eleição;
* **DT_ELEICAO** - Data em que ocorreu a eleição;
* **TP_ABRANGENCIA** - Tipo de abrangência da eleição;
* **SG_UF** - Sigla da Unidade da Federação em que ocorreu a eleição;
* **SG_UE** - Sigla da Unidade Eleitoral do candidato (em caso de eleição majoritária é a sigla da UF que o candidato concorre e em caso de eleição municipal é o código TSE do município);
* **NM_UE** - Nome da Unidade Eleitoral do candidato (em caso de eleição majoritária é o nome da UF que o candidato concorre e em caso de eleição municipal é o nome do município);
* **CD_MUNICIPIO** - Código TSE do município onde ocorreu a eleição;
* **NM_MUNICIPIO** - Nome do município onde ocorreu a eleição;
* **NR_ZONA** - Número da Zona Eleitoral onde ocorreu a eleição;
* **CD_CARGO** - Código do cargo do candidato;
* **DS_CARGO** - Descrição do cargo do candidato;
* **SQ_CANDIDATO** - Número sequencial do candidato gerado internamente pelos sistemas eleitorais (não é o número de campanha do candidato).
* **NR_CANDIDATO** - Número do candidato na urna;
* **NM_CANDIDATO** - Nome completo do candidato;
* **NM_URNA_CANDIDATO** - Nome de urna do candidato;
* **NM_SOCIAL_CANDIDATO** - Nome social do candidato;
* **CD_SITUACAO_CANDIDATURA** - Código da situação do registro de candidatura do candidato;
* **DS_SITUACAO_CANDIDATURA** - Descrição da situação do registro de candidatura do candidato (pode assumir os valores 'Apto'	[candidato apto para ir para urna], 'Inapto' [candidato inapto para ir para urna], 'Cadastrado' [registro de candidatura realizada, mas ainda não julgada]);
* **CD_DETALHE_SITUACAO_CAND** - Código do detalhe da situação do registro de candidatura do candidato;
* **DS_DETALHE_SITUACAO_CAND** - Descrição do detalhe da situação do registro de candidatura;
* **TP_AGREMIACAO** - Tipo de agremiação (pode assumir os valores 'Coligação' quando o candidato concorre por coligação e 'Partido isolado' quando o candidato concorre somente pelo partido);
* **NR_PARTIDO** - Número do partido do candidato;
* **SG_PARTIDO** - Sigla do partido do candidato;
* **NM_PARTIDO** - Nome do partido do candidato;
* **SQ_COLIGACAO** - Sequencial da coligação gerado pela Justiça Eleitoral, da qual o candidato pertence;
* **NM_COLIGACAO** - Nome da coligação da qual o candidato pertence;
* **DS_COMPOSICAO_COLIGACAO** - Descrição da composição da coligação da qual o candidato pertence;
* **CD_SIT_TOT_TURNO** - Código da situação de totalização do candidato naquele turno;
* **DS_SIT_TOT_TURNO** - Descrição da situação de totalização do candidato naquele turno;
* **ST_VOTO_EM_TRANSITO** - O indicativo se o quantitativo de votos se refere a voto em trânsito (pode assumir os valores S para Sim e N para Não);
* **QT_VOTOS_NOMINAIS** - Quantidade total de votos nominais do candidato naquele município e zona.

Por último, encerramos a seção configurando a maneira como o Seaborn irá gerar os seus gráficos. Para essa análise, escolhi, por julgar mais adequado, que o fundo das imagens seja branco e o contexto de exibição seja "notebook".

Isso fará com que as cores dos gráficos e a informação que eles desejam passar tenha mais destaque do que outros elementos (plano de fundo, linhas de grade, etc.) presentes.
"""

#Configurando preferências para visualização dos gráficos gerados pelo Seaborn.
sns.set_style("white")
sns.set_context("notebook")

"""# 3 - Tratando os dados

Antes de começarmos a extrair as informações, precisamos tratar a nossa base de dados. É necessáro saber inicialmente quantos e quais candidatos concorreram, além da quantidade de votos que cada um obteve. Com isso podemos começar a pensar em que tipos de gráficos serão gerados e quais informações podem ser extraídas.

## 3.1 - Candidatos

Para descobrir quantos candidatos concorreram, podemos fazer da seguinte forma:
"""

# Conta quantos candidatos concorreram no primeiro turno
candidatos_dataset["NM_URNA_CANDIDATO"].nunique()

"""Após sabermos que existem 13 candidatos, vamos conhecer seus nomes:"""

# Exibe o nome de todos os candidatos
candidatos_dataset["NM_URNA_CANDIDATO"].unique()

"""Com isso, já podemos fazer a primeira filtragem. Para os próximos gráficos, será necessário conhecer a quantidade de votos que cada candidato obteve por estado (incluindo no exterior, que aparece na base de dados com a sigla ZZ).

Essa informação é obtida através da criação de uma tabela pivô que será armazenada no dataframe **presidentes_por_estado**.
"""

# Cria um dataframe classificando os votos dos candidatos por estado
candidatos_por_estado = candidatos_dataset.pivot_table(
  index=["NM_URNA_CANDIDATO", "SG_UF"],
  values="QT_VOTOS_NOMINAIS",
  aggfunc=np.sum
)

# Reinicia o index por facilidade de referências futuras
candidatos_por_estado = candidatos_por_estado.reset_index()

"""## 3.2 - Cores

A partir das próximas seções começaremos a gerar gráficos. É muito importante que agora escolhamos a nossa paleta de cores, de preferência uma que possa ser visualizada por pessoas que possuem Daltonismo.

Como já verificamos, existem 28 estados (contando com ZZ) e 13 candidatos. Sendo assim, precisaremos ter uma quantidade de cores suficiente para lidar com essas informações. Extraí cores para a paleta através das anotações e dicas disponíveis em [Paul Tol's Notes](https://personal.sron.nl/~pault/) e criei duas listas (uma para a paleta com 13 cores e outra para a com 28).
"""

# Paleta com 13 cores amigáveis para daltônicos
paleta_13 = [
    '#332288', '#88CCEE', '#44AA99', '#117733', '#999933', '#DDCC77', '#CC6677',
    '#882255', '#AA4499', '#DDDDDD', '#EE7733', '#CC3311', '#EE3377'
]

# Paleta com 28 cores amigáveis para daltônicos
paleta_28 = [
    '#332288', '#88CCEE', '#44AA99', '#117733', '#999933', '#DDCC77', '#CC6677',
    '#882255', '#AA4499', '#DDDDDD', '#EE7733', '#CC3311', '#EE3377', '#000000',
    '#004488', '#FFB000', '#648FFF', '#FFEE99', '#5AAE61', '#9970AB', '#662506',
    '#AE76A3', '#BEBC48', '#4E79C5', '#E67932', '#222255', '#666633', '#663333'
]

"""## 3.3 Resultado por candidato

Com as informações básicas classificadas, podemos gerar o primeiro gráfico. Com ele é possível "sentir" como os votos estão concentrados e a partir disso orientar as próximas visualizações.
"""

# Cria um gráfico contendo a quantidade de votos que cada candidato obteve
fig = plt.figure(figsize=(12,8))
plt.tight_layout()

# Plota um gráfico com a quantidade total de votos por candidato
ax = sns.barplot(
    x="NM_URNA_CANDIDATO",
    y="QT_VOTOS_NOMINAIS",
    data=candidatos_por_estado,
    palette=paleta_13
)

# Remove todas as colunas laterais
sns.despine(left=True, bottom=True)

# Rotaciona o nome dos candidatos nomeia os eixos
plt.xticks(rotation=90)
plt.xlabel("Candidatos")
plt.ylabel("Votos")

# Gera o gráfico
plt.show()

"""Com esse gráfico temos apenas uma rápida visualização do resultado do primeiro turno das eleições. Como é possível observar, os candidatos Ciro Gomes, Fernando Haddad e Jair Bolsonaro foram os três com o maior número de votos. Eymael, João Goulart Filho e Vera, porém, não obteram um valor significativo (comparado com a escala dos demais).

Percebe-se também que a diferença de votos no top 3 não é sutil (principalmente entre o primeiro e o segundo). Iremos, com os próximos gráficos, visualizar o desempenho individual dos candidatos em cada estado, podendo identificar quais foram seus maiores colégios eleitorais.

#4 - Votos dos candidatos por estado

Como dito na seção anterior, vamos analisar agora o desempenho individual dos candidatos por estado (incluindo votos no exterior, que possuem a sigla ZZ).

Já evidenciamos também que o número de votos entre os candidatos diferente bastante: apenas fora do top 3 é que temos votos flutuando aproximadamente na mesma escala. Por causa disso, procurei uma forma de normalizar essa quantidade. Escolhi calcular a quantidade total de votos por estado e depois verificar qual a porcentagem desses votos os candidatos (individualmente) obtiveram.

O primeiro passo é, então, descobrir qual a quantidade de votos cada estado teve.
"""

# Cria um dataframe com a quantidade de votos por estado
votos_estado = candidatos_dataset.pivot_table(index="SG_UF", values="QT_VOTOS_NOMINAIS", aggfunc=np.sum)
votos_estado = votos_estado.rename(columns={'QT_VOTOS_NOMINAIS': 'TOTAL_VOTOS'})
votos_estado

"""Agora, para facilitar o cálculo da porcentagem, decidi concatenar os valores de **votos_estado** com os dados contidos em **candidatos_por_estado**."""

# Concatena colunas para calcular a porcentagem dos votos por estado
candidatos_por_estado = pd.concat([candidatos_por_estado.set_index("SG_UF"), votos_estado], axis=1, join='inner')
candidatos_por_estado

"""Finalmente podemos calcular a porcentagem total de votos no estado que cada candidato obteve:"""

# Calcula a porcentagem de votos que cada candidato obteve por estado
candidatos_por_estado = candidatos_por_estado.assign(
    PORCENTAGEM_VTS_ESTADO=lambda x:round(100 * x["QT_VOTOS_NOMINAIS"]/x["TOTAL_VOTOS"],2)
)

# Exclui a coluna que foi utilizada para o cálculo, visto que suas informações podem confundir futuramente
candidatos_por_estado = candidatos_por_estado.drop(['TOTAL_VOTOS'], axis=1).reset_index()

candidatos_por_estado

"""Por último, geramos os gráficos para conhecer o desempenho individual de cada candidato."""

# Gera gráficos para ver o desempenho de cada candidato por estado
for candidato in candidatos_dataset["NM_URNA_CANDIDATO"].unique():
  fig = plt.figure(figsize=(12,8))
  plt.tight_layout()
  candidato_estado = candidatos_por_estado[candidatos_por_estado["NM_URNA_CANDIDATO"] == candidato]
  ax = sns.barplot(
    x="NM_URNA_CANDIDATO",
    y="PORCENTAGEM_VTS_ESTADO",
    hue="SG_UF",
    data=candidato_estado,  
    palette=paleta_28
  )
  
  votos_list = list(candidato_estado["QT_VOTOS_NOMINAIS"].values.flatten())
  count = 0
  
  # Cria anotações para que em cima de cada barra tenha a quantidade nominal de votos
  for i in ax.patches:
    text = "   {} votos".format(votos_list[count])
    ax.text(
        i.get_x() + i.get_width()/2.0,
        i.get_height(),
        text, color='black', ha="center", va='bottom', rotation=90,
        fontsize=11
    )
    count += 1 
  
  sns.despine(left=True, bottom=True)
  plt.xlabel("Candidato")
  plt.ylabel("Porcentagem de Votos")
  plt.show()

"""Desses gráficos, podemos observar várias informações.

Mesmo sendo paulista, o candidato Guilherme Boulos teve a maioria dos

# 5 - Presidentes por região

Me interessei por saber quais foram a porcentagem de votos que os três mais votados candidatos receberam das cinco regiões do Brasil. De análises anteriores, já vimos que Fernando Haddad, Ciro Gomes e Jair Bolsonaro são os nomes a quais devemos procurar.

Inicialmente, precisamos classificar os estados do nosso conjunto de dados por região. Uma das formas para fazer isso é:
"""

#Criando um dicionário com a região atribuída a cada estado
estado_regioes={
    'AC': ['NORTE'],
    'AL': ['NORDESTE'],
    'AM': ['NORTE'],
    'AP': ['NORTE'],
    'BA': ['NORDESTE'],
    'CE': ['NORDESTE'],
    'DF': ['CENTRO-OESTE'],
    'ES': ['SUDESTE'],
    'GO': ['CENTRO-OESTE'],
    'MA': ['NORDESTE'],
    'MG': ['SUDESTE'],
    'MS': ['CENTRO-OESTE'],
    'MT': ['CENTRO-OESTE'],
    'PA': ['NORTE'],
    'PB': ['NORDESTE'],
    'PE': ['NORDESTE'],
    'PI': ['NORDESTE'],
    'PR': ['SUL'],
    'RJ': ['SUDESTE'],
    'RN': ['NORDESTE'],
    'RO': ['NORTE'],
    'RR': ['NORTE'],
    'RS': ['SUL'],
    'SC': ['SUL'],
    'SE': ['NORDESTE'],
    'SP': ['SUDESTE'],
    'TO': ['NORTE'],
    'ZZ': ['EXTERIOR']
}

# Criando um dataframe a partir da lista de estados/regiões
regioes = pd.DataFrame.from_dict(estado_regioes).T.rename(columns={0: 'REGIAO'}).reset_index().rename(columns={'index': 'SG_UF'}).set_index('SG_UF')
regioes

"""Agora, podemos concatenar as colunas para conhecer também, além do estado, a região do voto."""

# Concatena as colunas para adicionar informação de região
candidatos_por_estado = pd.concat([candidatos_por_estado.set_index('SG_UF'), regioes], axis=1, join='inner')
candidatos_por_estado = candidatos_por_estado.reset_index()
candidatos_por_estado.head()

"""Porém, é necessário ainda saber a porcentagem que aqueles votos representam na região. Isso é feito da seguinte forma:"""

# Cria um dataframe com a quantidade de votos por região
votos_regiao = candidatos_por_estado.pivot_table(index="REGIAO", values="QT_VOTOS_NOMINAIS", aggfunc=np.sum)
votos_regiao = votos_regiao.rename(columns={'QT_VOTOS_NOMINAIS': 'TOTAL_VOTOS_REGIAO'})
votos_regiao

"""Concatenando mais uma vez as informações para visualizar e calcular a porcentagem:"""

# Cria um novo conjunto de dados contendo a quantidade de votos do candidato por região
candidatos_por_regiao = candidatos_por_estado.pivot_table(
    index=["NM_URNA_CANDIDATO", "REGIAO"], values="QT_VOTOS_NOMINAIS", aggfunc=np.sum
)

candidatos_por_regiao = candidatos_por_regiao.reset_index()

# Concatena com a quantidade total de votos por região
candidatos_por_regiao = pd.concat([candidatos_por_regiao.set_index("REGIAO"), votos_regiao], axis=1, join='inner')

# Calcula a porcentagem desses votos em relação ao total 
candidatos_por_regiao = candidatos_por_regiao.assign(
    PORCENTAGEM_VTS_REGIAO=lambda x:round(100 * x["QT_VOTOS_NOMINAIS"]/x["TOTAL_VOTOS_REGIAO"],2)
)

# Exclui a coluna que foi utilizada para o cálculo, visto que suas informações podem confundir futuramente
candidatos_por_regiao = candidatos_por_regiao.drop(['TOTAL_VOTOS_REGIAO'], axis=1).reset_index()

candidatos_por_regiao

"""Com os dados prontos, podemos plotar gráficos para ver a posição dos três candidatos com a maior quantidade de votos classificados por região."""

# Criando gráfico de votos por região (porcentagem) para os três candidatos com mais votos
fig = plt.figure(figsize=(10,6))
plt.tight_layout()

# Selecionando os candidatos
haddad = candidatos_por_regiao[candidatos_por_regiao["NM_URNA_CANDIDATO"] == "FERNANDO HADDAD"]
bolsonaro = candidatos_por_regiao[candidatos_por_regiao["NM_URNA_CANDIDATO"] == "JAIR BOLSONARO"]
ciro = candidatos_por_regiao[candidatos_por_regiao["NM_URNA_CANDIDATO"] == "CIRO GOMES"]
candidatos_selecionados = [ciro, haddad, bolsonaro]
top3 = pd.concat(candidatos_selecionados)

# Cria uma paleta de cores especial para o top 3, amigável para daltônicos
top3_paleta = ["#4477AA", "#CC3311", "#228833"]

# Gerando o gráfico
ax = sns.barplot(
    x="REGIAO", y="PORCENTAGEM_VTS_REGIAO", hue="NM_URNA_CANDIDATO",
    data=top3, palette=top3_paleta
)

# Coletando informações textuais
count = 0
top3_votos = []
top3_votos.extend(list(ciro["QT_VOTOS_NOMINAIS"].values.flatten()))
top3_votos.extend(list(haddad["QT_VOTOS_NOMINAIS"].values.flatten()))
top3_votos.extend(list(bolsonaro["QT_VOTOS_NOMINAIS"].values.flatten()))

# Gerando anotações sobre a quantidade de votos
for i in ax.patches:
    text = "  {} votos".format(top3_votos[count])
    ax.text(
        i.get_x() + i.get_width()/2.0,
        i.get_height(),
        text, color='black', ha="center", va='bottom', rotation=90,
        fontsize=11
    )
    count += 1

# Configurando labels, legenda e mostrando o gráfico na tela    
sns.despine(left=True, bottom=True)
plt.xlabel("Região")
plt.ylabel("Porcentagem de Votos Por Região")
plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)
plt.show()

"""Procurei observar, através do Censo 2010 do [IBGE](https://censo2010.ibge.gov.br/sinopse/index.php?dados=12) informações referentes a faixa etária da população para descobrir se havia alguma correlação idade e escolha dos candidatos. Como não tive acesso a uma base de dados para converter ao Pandas, não houve como gerar um gráfico de dispersão.

Apenas por análise visual dos gráficos do IBGE é possível notar que não há uma relação tão forte entre idade e a escolha do voto. No Nordeste, por exemplo, onde o candidato Fernando Haddad teve a maioria dos votos, a população é levemente mais jovem que no Sudeste, onde Jair Bolsonaro alcançou maioria.

Fatores políticos e sociais pesam bastante nessa escolha.

# 6 - Conclusão

A quantidade de trabalho para ser feito é bem maior do que a que realmente foi entregue. Houveram dificuldades para tratar os dados, escolher os gráficos e fazer as escolhas referentes ao que eu gostaria de pesquisar.

Aprendi muito durante todo o processo, vendo o quanto é árduo tratar os dados para deixá-los prontos para uma visualização.

Percebi também que o resultado final do primeiro turno das eleições presidenciais aproxima-se do que as pesquisas eleitorais previam.
"""